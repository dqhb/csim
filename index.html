<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>parkour</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e2f; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid #555;
        }
        #center-dot {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #checkpoint-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #10b981; font-size: 2rem; font-weight: bold; font-family: monospace;
            text-shadow: 2px 2px 0 #000; display: none; pointer-events: none;
        }
        .highlight { color: #facc15; font-weight: bold; }
        #score-text { font-size: 1.4rem; color: #38bdf8; font-weight: bold; margin: 10px 0 0 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h2 style="margin: 0 0 10px 0; color: #38bdf8;">Parkour Flow</h2>
        <p><span class="highlight">W A S D</span> : Move / Strafe</p>
        <p><span class="highlight">CTRL</span> : Sprint</p>
        <p><span class="highlight">SPACE</span> : Jump</p>
        <p><span class="highlight">ARROW KEYS</span> : Look Around</p>
        <hr style="border-color: #555;">
        <p id="score-text">Score: 0</p>
    </div>

    <div id="center-dot"></div>
    <div id="checkpoint-msg">CHECKPOINT!</div>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e1e2f);
        scene.fog = new THREE.Fog(0x1e1e2f, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- 2. GAME STATE & PHYSICS ---
        const player = {
            pos: new THREE.Vector3(0, 5, 0),
            vel: new THREE.Vector3(0, 0, 0),
            size: new THREE.Vector3(0.8, 1.8, 0.8), 
            isGrounded: false,
            yaw: 0,   
            pitch: 0  
        };

        const physics = {
            gravity: 0.012,
            jumpPower: 0.28,
            baseSpeed: 0.14,  
            sprintMult: 1.6,  
            airControl: 0.85  
        };

        let currentCheckpoint = new THREE.Vector3(0, 5, 0);
        let score = 0;
        let highestPlatReached = 0;
        let groundTimer = 0; // Coyote time

        // --- 3. INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', e => { 
            keys[e.code] = true; 
            if(["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) > -1) e.preventDefault();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- 4. WINDING LEVEL GENERATOR ---
        const platforms = []; 
        const hitboxes = [];  
        let platformIndex = 0;
        let lastPos = new THREE.Vector3(0, 0, 0);
        let currentPathAngle = 0; // Controls the winding direction

        const blockGeo = new THREE.BoxGeometry(1, 1, 1);
        const cpMat = new THREE.MeshLambertMaterial({ color: 0x10b981 }); 

        function createBlock(x, y, z, w, h, d, material, isCheckpoint = false) {
            const mesh = new THREE.Mesh(blockGeo, material);
            mesh.scale.set(w, h, d);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            platforms.push(mesh);

            const box = new THREE.Box3().setFromObject(mesh);
            hitboxes.push(box);

            if (isCheckpoint) {
                mesh.userData.isCheckpoint = true;
                mesh.userData.cpPos = new THREE.Vector3(x, y + h/2 + 2, z);
            }
            return mesh;
        }

        function generateNextPlatform() {
            platformIndex++;
            
            // Winding Path Logic: Shift angle slightly left or right
            currentPathAngle += (Math.random() - 0.5) * 1.2; 
            
            // Distance and Height gaps
            let gapDist = 3.5 + Math.random() * 2.5; 
            let gapY = (Math.random() - 0.5) * 2.5; 

            if (gapY > 1.2) gapY = 1.2; 
            if (gapY < -2.0) gapY = -2.0;

            // Apply trigonometry to move the next platform along the winding angle
            lastPos.x += Math.sin(currentPathAngle) * gapDist;
            lastPos.y += gapY;
            lastPos.z -= Math.cos(currentPathAngle) * gapDist; 

            let isCp = (platformIndex % 10 === 0); 
            let color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
            let mat = isCp ? cpMat : new THREE.MeshLambertMaterial({ color: color });

            let platW = isCp ? 5 : 3 + Math.random() * 2;
            let platD = isCp ? 5 : 3 + Math.random() * 2;

            let mainPlat = createBlock(lastPos.x, lastPos.y, lastPos.z, platW, 0.5, platD, mat, isCp);
            mainPlat.userData.id = platformIndex; // Tag it for scoring

            // Occasional Neos (No more headhitters)
            if (!isCp && Math.random() < 0.25) {
                // Wall in the middle to strafe around
                createBlock(lastPos.x, lastPos.y + 2, lastPos.z, 2.5, 4, 0.5, mat);
            }
        }

        // Generate starting block
        let startPlat = createBlock(0, 0, 0, 6, 0.5, 6, cpMat, true);
        startPlat.userData.id = 0;
        for(let i=0; i<15; i++) generateNextPlatform();

        function showCheckpointUI() {
            const msg = document.getElementById('checkpoint-msg');
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; }, 1500);
        }

        // --- 5. HITBOX & SCORING SYSTEM ---
        const playerBox = new THREE.Box3();
        
        function updatePlayerHitbox(offsetX = 0, offsetY = 0, offsetZ = 0) {
            playerBox.min.set(player.pos.x - player.size.x/2 + offsetX, player.pos.y + offsetY, player.pos.z - player.size.z/2 + offsetZ);
            playerBox.max.set(player.pos.x + player.size.x/2 + offsetX, player.pos.y + player.size.y + offsetY, player.pos.z + player.size.z/2 + offsetZ);
        }

        function checkCollisions() {
            let hit = false;
            for (let i = 0; i < hitboxes.length; i++) {
                if (playerBox.intersectsBox(hitboxes[i])) {
                    hit = true;
                    let pData = platforms[i].userData;
                    
                    // Score Tracker
                    if (pData.id !== undefined && pData.id > highestPlatReached) {
                        highestPlatReached = pData.id;
                        score++;
                        document.getElementById('score-text').innerText = `Score: ${score}`;
                    }

                    // Checkpoints
                    if (pData.isCheckpoint) {
                        if (currentCheckpoint.distanceTo(pData.cpPos) > 1) {
                            currentCheckpoint.copy(pData.cpPos);
                            showCheckpointUI();
                        }
                    }
                }
            }
            return hit;
        }

        function die() {
            player.pos.copy(currentCheckpoint);
            player.vel.set(0,0,0);
            player.yaw = 0;
            player.pitch = 0;
        }

        // --- 6. MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // CAMERA CONTROLS
            if (keys['ArrowLeft']) player.yaw += 0.04;
            if (keys['ArrowRight']) player.yaw -= 0.04;
            if (keys['ArrowUp']) player.pitch += 0.04;
            if (keys['ArrowDown']) player.pitch -= 0.04;
            player.pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, player.pitch));

            // JUMP LOGIC (With Coyote Time)
            if (keys['Space'] && (player.isGrounded || groundTimer > 0)) {
                player.vel.y = physics.jumpPower;
                player.isGrounded = false;
                groundTimer = 0;
            }

            // MOVEMENT INTENT 
            let moveX = 0; let moveZ = 0;
            if (keys['KeyW']) moveZ -= 1;
            if (keys['KeyS']) moveZ += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            if (moveX !== 0 || moveZ !== 0) {
                let length = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX /= length; moveZ /= length;
            }

            let currentSpeed = physics.baseSpeed;
            if (keys['ControlLeft'] || keys['ControlRight']) currentSpeed *= physics.sprintMult;

            let sinY = Math.sin(player.yaw);
            let cosY = Math.cos(player.yaw);
            
            let targetVx = (moveX * cosY + moveZ * sinY) * currentSpeed;
            let targetVz = (-moveX * sinY + moveZ * cosY) * currentSpeed;

            let control = player.isGrounded ? 1 : physics.airControl;
            player.vel.x += (targetVx - player.vel.x) * 0.2 * control;
            player.vel.z += (targetVz - player.vel.z) * 0.2 * control;

            player.vel.y -= physics.gravity;

            // --- COLLISION RESOLUTION ---
            player.isGrounded = false;

            updatePlayerHitbox(player.vel.x, 0, 0);
            if (checkCollisions()) player.vel.x = 0; 
            else player.pos.x += player.vel.x;

            updatePlayerHitbox(0, player.vel.y, 0);
            if (checkCollisions()) {
                if (player.vel.y < 0) {
                    player.isGrounded = true; 
                    groundTimer = 6; // 6 frames of leniency after walking off an edge
                }
                player.vel.y = 0; 
            } else {
                player.pos.y += player.vel.y;
                if (groundTimer > 0) groundTimer--;
            }

            updatePlayerHitbox(0, 0, player.vel.z);
            if (checkCollisions()) player.vel.z = 0; 
            else player.pos.z += player.vel.z;

            // --- UPDATE CAMERA ---
            camera.position.set(player.pos.x, player.pos.y + player.size.y - 0.2, player.pos.z);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

            // --- DEATH & DYNAMIC CHUNK LOADING ---
            if (player.pos.y < -15) die();

            // Load new platforms based on your highest score rather than Z depth
            if (highestPlatReached > platformIndex - 12) {
                for(let i=0; i<5; i++) generateNextPlatform();
                
                // Cleanup old platforms to prevent lag
                while(platforms.length > 50) {
                    let oldMesh = platforms.shift();
                    scene.remove(oldMesh);
                    hitboxes.shift();
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
