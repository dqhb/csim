<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>parkour</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e2f; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid #555;
        }
        #center-dot {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #checkpoint-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #10b981; font-size: 2rem; font-weight: bold; font-family: monospace;
            text-shadow: 2px 2px 0 #000; display: none; pointer-events: none;
        }
        .highlight { color: #facc15; font-weight: bold; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h2 style="margin: 0 0 10px 0; color: #38bdf8;">Parkour Run</h2>
        <p><span class="highlight">W A S D</span> : Move / Strafe</p>
        <p><span class="highlight">SPACE</span> : Jump</p>
        <p><span class="highlight">ARROW KEYS</span> : Look Around</p>
        <hr style="border-color: #555;">
        <p>Green platforms = <span class="highlight">Checkpoints</span></p>
    </div>

    <div id="center-dot"></div>
    <div id="checkpoint-msg">CHECKPOINT REACHED!</div>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e1e2f);
        scene.fog = new THREE.Fog(0x1e1e2f, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- 2. PLAYER & PHYSICS STATE ---
        const player = {
            pos: new THREE.Vector3(0, 5, 0),
            vel: new THREE.Vector3(0, 0, 0),
            size: new THREE.Vector3(0.8, 1.8, 0.8), // Player Hitbox (Width, Height, Depth)
            isGrounded: false,
            yaw: 0,   // Left/Right rotation
            pitch: 0  // Up/Down rotation
        };

        const physics = {
            gravity: 0.012,
            jumpPower: 0.28,
            speed: 0.12,
            friction: 0.8,
            airControl: 0.6
        };

        let currentCheckpoint = new THREE.Vector3(0, 5, 0);

        // --- 3. INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', e => { 
            keys[e.code] = true; 
            if (e.code === 'Space' && player.isGrounded) {
                player.vel.y = physics.jumpPower;
                player.isGrounded = false;
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- 4. INFINITE LEVEL GENERATOR ---
        const platforms = []; // Stores meshes
        const hitboxes = [];  // Stores Box3s for collision
        let platformIndex = 0;
        let lastPos = new THREE.Vector3(0, 0, 0);

        const blockGeo = new THREE.BoxGeometry(1, 1, 1);
        const cpMat = new THREE.MeshLambertMaterial({ color: 0x10b981 }); // Checkpoint green

        function createBlock(x, y, z, w, h, d, material, isCheckpoint = false) {
            const mesh = new THREE.Mesh(blockGeo, material);
            mesh.scale.set(w, h, d);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            platforms.push(mesh);

            const box = new THREE.Box3().setFromObject(mesh);
            hitboxes.push(box);

            if (isCheckpoint) {
                mesh.userData.isCheckpoint = true;
                mesh.userData.cpPos = new THREE.Vector3(x, y + h/2 + 2, z);
            }
        }

        function generateNextPlatform() {
            platformIndex++;
            
            // Randomize distance and height
            let gapZ = 3.5 + Math.random() * 2.5; // Forward gap
            let gapX = (Math.random() - 0.5) * 4; // Left/Right shift
            let gapY = (Math.random() - 0.5) * 3; // Up/Down shift

            // Cap the downward and upward shifts so it's jumpable
            if (gapY > 1.5) gapY = 1.5; 
            if (gapY < -2) gapY = -2;

            lastPos.x += gapX;
            lastPos.y += gapY;
            lastPos.z -= gapZ; // Move forward into negative Z

            let typeRoll = Math.random();
            let isCp = (platformIndex % 10 === 0); // Checkpoint every 10 jumps
            
            let color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
            let mat = isCp ? cpMat : new THREE.MeshLambertMaterial({ color: color });

            let platW = isCp ? 4 : 2 + Math.random() * 1.5;
            let platD = isCp ? 4 : 2 + Math.random() * 1.5;

            // Base platform
            createBlock(lastPos.x, lastPos.y, lastPos.z, platW, 0.5, platD, mat, isCp);

            if (!isCp) {
                if (typeRoll < 0.2) {
                    // HEADHITTER: Add a ceiling block exactly 2.1 units above the platform
                    createBlock(lastPos.x, lastPos.y + 2.4, lastPos.z, platW, 0.5, platD, mat);
                } else if (typeRoll < 0.4) {
                    // NEO: Add a wall in the middle, pushing the player to jump around it
                    createBlock(lastPos.x, lastPos.y + 2, lastPos.z + platD/2 + 0.5, 3, 4, 0.5, mat);
                }
            }
        }

        // Generate initial starting area
        createBlock(0, 0, 0, 5, 0.5, 5, cpMat, true);
        for(let i=0; i<15; i++) generateNextPlatform();

        function showCheckpointUI() {
            const msg = document.getElementById('checkpoint-msg');
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; }, 1500);
        }

        // --- 5. CUSTOM HITBOX COLLISION SYSTEM ---
        const playerBox = new THREE.Box3();
        
        function updatePlayerHitbox(offsetX = 0, offsetY = 0, offsetZ = 0) {
            playerBox.min.set(player.pos.x - player.size.x/2 + offsetX, player.pos.y + offsetY, player.pos.z - player.size.z/2 + offsetZ);
            playerBox.max.set(player.pos.x + player.size.x/2 + offsetX, player.pos.y + player.size.y + offsetY, player.pos.z + player.size.z/2 + offsetZ);
        }

        function checkCollisions() {
            for (let i = 0; i < hitboxes.length; i++) {
                if (playerBox.intersectsBox(hitboxes[i])) {
                    // Check if it's a checkpoint platform
                    if (platforms[i].userData.isCheckpoint) {
                        if (currentCheckpoint.distanceTo(platforms[i].userData.cpPos) > 1) {
                            currentCheckpoint.copy(platforms[i].userData.cpPos);
                            showCheckpointUI();
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        function die() {
            player.pos.copy(currentCheckpoint);
            player.vel.set(0,0,0);
            player.yaw = 0;
            player.pitch = 0;
        }

        // --- 6. MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // CAMERA CONTROLS (Arrow Keys)
            if (keys['ArrowLeft']) player.yaw += 0.04;
            if (keys['ArrowRight']) player.yaw -= 0.04;
            if (keys['ArrowUp']) player.pitch += 0.04;
            if (keys['ArrowDown']) player.pitch -= 0.04;
            
            // Clamp pitch to look straight up/down
            player.pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, player.pitch));

            // MOVEMENT INTENT (WASD mapped to Yaw direction)
            let moveX = 0; let moveZ = 0;
            if (keys['KeyW']) moveZ -= 1;
            if (keys['KeyS']) moveZ += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            // Normalize diagonal movement
            if (moveX !== 0 || moveZ !== 0) {
                let length = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX /= length; moveZ /= length;
            }

            // Apply camera rotation to movement vector
            let sinY = Math.sin(player.yaw);
            let cosY = Math.cos(player.yaw);
            
            let targetVx = (moveX * cosY + moveZ * sinY) * physics.speed;
            let targetVz = (-moveX * sinY + moveZ * cosY) * physics.speed;

            // Apply friction/acceleration
            let control = player.isGrounded ? 1 : physics.airControl;
            player.vel.x += (targetVx - player.vel.x) * 0.2 * control;
            player.vel.z += (targetVz - player.vel.z) * 0.2 * control;

            // Apply Gravity
            player.vel.y -= physics.gravity;

            // --- AXIS-BY-AXIS COLLISION RESOLUTION ---
            player.isGrounded = false;

            // Move X
            updatePlayerHitbox(player.vel.x, 0, 0);
            if (checkCollisions()) {
                player.vel.x = 0; // Hit a wall, stop X velocity
            } else {
                player.pos.x += player.vel.x;
            }

            // Move Y
            updatePlayerHitbox(0, player.vel.y, 0);
            if (checkCollisions()) {
                if (player.vel.y < 0) {
                    player.isGrounded = true; // Landed on floor
                }
                player.vel.y = 0; // Hit floor or headhitter ceiling, stop Y velocity
            } else {
                player.pos.y += player.vel.y;
            }

            // Move Z
            updatePlayerHitbox(0, 0, player.vel.z);
            if (checkCollisions()) {
                player.vel.z = 0; // Hit a wall, stop Z velocity
            } else {
                player.pos.z += player.vel.z;
            }

            // Update Camera Position & Rotation
            camera.position.set(player.pos.x, player.pos.y + player.size.y - 0.2, player.pos.z);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

            // --- DEATH & WORLD GENERATION ---
            // Fall into the void
            if (player.pos.y < -15) die();

            // Infinite world generation (if player gets close to the end of the loaded array)
            if (player.pos.z < platforms[platforms.length - 5].position.z) {
                for(let i=0; i<5; i++) generateNextPlatform();
                
                // Cleanup old platforms behind us to save memory
                while(platforms.length > 30) {
                    let oldMesh = platforms.shift();
                    scene.remove(oldMesh);
                    hitboxes.shift();
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
