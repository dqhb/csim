<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fsim</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
            pointer-events: none; text-shadow: 1px 1px 2px black;
        }
        #hud {
            position: absolute; bottom: 30px; right: 30px; color: #10b981;
            background: rgba(0, 0, 0, 0.8); padding: 15px 25px; border-radius: 8px;
            font-size: 1.2rem; font-family: monospace; text-align: right;
        }
        .warning { color: #ef4444; font-weight: bold; animation: blink 1s infinite; display: none; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h2 style="margin: 0 0 10px 0; color: #38bdf8;">Pro Flight Sim</h2>
        <p><b>W / S</b> : Pitch | <b>A / D</b> : Yaw | <b>Q / E</b> : Roll</p>
        <p><b>↑ / ↓</b> : Throttle</p>
        <p style="color: #fbbf24; font-size: 0.9em;">Physics Active: Watch your lift!</p>
    </div>

    <div id="hud">
        <div id="stallWarning" class="warning">STALL WARNING</div>
        <div id="speedometer">Speed: 0 kts</div>
        <div id="altimeter">Alt: 0 ft</div>
    </div>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x60a5fa);
        scene.fog = new THREE.FogExp2(0x60a5fa, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(500, 1000, 500);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // --- 2. PROCEDURAL TEXTURES (The "Detail" Hack) ---
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, 128, 256); // Base color
            ctx.fillStyle = '#fef08a'; // Window light color
            for(let y = 10; y < 256; y += 15) {
                for(let x = 10; x < 128; x += 15) {
                    if(Math.random() > 0.3) ctx.fillRect(x, y, 8, 10); // Draw windows
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
        const buildingMat = new THREE.MeshLambertMaterial({ map: createBuildingTexture() });

        // --- 3. ENVIRONMENT & CITY ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000), 
            new THREE.MeshLambertMaterial({ color: 0x22c55e })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Runways (Airport 1 and Airport 2)
        function createRunway(x, z, rotationY) {
            const rw = new THREE.Mesh(new THREE.PlaneGeometry(60, 1000), new THREE.MeshLambertMaterial({ color: 0x334155 }));
            rw.rotation.x = -Math.PI / 2; rw.rotation.y = rotationY; rw.position.set(x, 0.5, z);
            scene.add(rw);
        }
        createRunway(0, -400, 0);       // Starting Airport
        createRunway(3000, -2000, 1.5); // Distant Airport

        // Roads
        const roadMat = new THREE.MeshLambertMaterial({ color: 0x1e293b });
        for(let i=0; i<5; i++) {
            const road = new THREE.Mesh(new THREE.PlaneGeometry(30, 4000), roadMat);
            road.rotation.x = -Math.PI / 2; road.position.set(-500 + (i*500), 0.2, 0);
            scene.add(road);
        }

        // City Generator
        const buildings = [];
        for (let i = 0; i < 400; i++) {
            let w = 20 + Math.random() * 30, d = 20 + Math.random() * 30, h = 50 + Math.random() * 250;
            let x = (Math.random() - 0.5) * 4000, z = (Math.random() - 0.5) * 4000;
            
            // Keep clear of runways
            if ((Math.abs(x) < 150 && z < 200 && z > -1000) || (Math.abs(x - 3000) < 600 && Math.abs(z + 2000) < 150)) continue;

            const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), buildingMat);
            b.position.set(x, h / 2, z);
            b.castShadow = true; b.receiveShadow = true;
            
            // Fix texture stretching
            buildingMat.map.repeat.set(w/50, h/50);
            
            scene.add(b);
            buildings.push(b);
        }

        // --- 4. TRAFFIC SYSTEM ---
        const cars = [];
        const carGeo = new THREE.BoxGeometry(2, 2, 4);
        const carMats = [new THREE.MeshLambertMaterial({color: 0xff0000}), new THREE.MeshLambertMaterial({color: 0x0000ff}), new THREE.MeshLambertMaterial({color: 0xffffff})];
        
        for(let i=0; i<50; i++) {
            let roadIndex = Math.floor(Math.random() * 5);
            let car = new THREE.Mesh(carGeo, carMats[Math.floor(Math.random() * carMats.length)]);
            car.position.set(-500 + (roadIndex*500), 1, (Math.random() - 0.5) * 4000);
            car.userData = { speed: 0.5 + Math.random(), dir: Math.random() > 0.5 ? 1 : -1 };
            scene.add(car);
            cars.push(car);
        }

        // --- 5. AIRCRAFT ---
        const plane = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 8), new THREE.MeshLambertMaterial({ color: 0xf8fafc }));
        const wings = new THREE.Mesh(new THREE.BoxGeometry(20, 0.2, 3), new THREE.MeshLambertMaterial({ color: 0xef4444 }));
        const tail = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 2), new THREE.MeshLambertMaterial({ color: 0xef4444 }));
        tail.position.set(0, 0.5, 3.5);
        plane.add(body); plane.add(wings); plane.add(tail);
        scene.add(plane);

        // --- 6. ADVANCED PHYSICS STATE ---
        let speed = 0;
        let verticalVelocity = 0; // NEW: Controls falling
        const maxSpeed = 4.0;
        const gravity = 0.05; 
        const liftFactor = 0.015; // How much lift speed generates
        const turnSpeed = 0.025;

        function resetFlight() {
            plane.position.set(0, 2, 80);
            plane.rotation.set(0, 0, 0);
            speed = 0; verticalVelocity = 0;
        }
        resetFlight();

        // --- 7. INPUTS ---
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- 8. MAIN LOOP ---
        const planeBox = new THREE.Box3();
        const buildingBox = new THREE.Box3();

        function animate() {
            requestAnimationFrame(animate);

            // Throttle
            if (keys['ArrowUp']) speed += 0.015;
            if (keys['ArrowDown']) speed -= 0.02;
            if (!keys['ArrowUp'] && !keys['ArrowDown']) speed *= 0.995; // Drag
            speed = Math.max(0, Math.min(maxSpeed, speed));

            // --- AERODYNAMICS (Lift & Gravity) ---
            // Lift is based on speed. Rolling the plane decreases vertical lift (spills air).
            let currentRoll = Math.abs(plane.rotation.z);
            let lift = (speed * speed) * liftFactor * Math.cos(currentRoll); 
            
            // Stall Warning
            const stallWarning = document.getElementById('stallWarning');
            if (plane.position.y > 10 && lift < gravity) stallWarning.style.display = 'block';
            else stallWarning.style.display = 'none';

            // Apply gravity and lift to vertical velocity
            verticalVelocity += lift - gravity;
            
            // Add pitch vector to vertical velocity (pointing nose up makes you go up if you have speed)
            verticalVelocity -= Math.sin(plane.rotation.x) * speed * 0.1;

            // Apply vertical movement
            plane.position.y += verticalVelocity;

            // Ground Interaction
            if (plane.position.y <= 2) {
                // Crash check (too fast vertically, or bad angle)
                if (verticalVelocity < -1.5 || Math.abs(plane.rotation.x) > 0.4 || Math.abs(plane.rotation.z) > 0.4) {
                    resetFlight();
                } else {
                    plane.position.y = 2; // Taxiing
                    verticalVelocity = 0;
                    plane.rotation.x = 0;
                    plane.rotation.z = 0;
                }
            }

            // --- CONTROLS ---
            let controlPower = Math.min(1, speed / 1.0); // Need speed to steer
            if (plane.position.y > 2.5 || speed > 1) {
                if (keys['KeyW']) plane.rotateX(turnSpeed * controlPower);  
                if (keys['KeyS']) plane.rotateX(-turnSpeed * controlPower); 
                if (keys['KeyQ']) plane.rotateZ(turnSpeed * controlPower);  
                if (keys['KeyE']) plane.rotateZ(-turnSpeed * controlPower); 
            }
            // Yaw (Rudder) works on ground too
            if (keys['KeyA']) plane.rotateY(turnSpeed * (plane.position.y <= 2 ? 1 : controlPower));  
            if (keys['KeyD']) plane.rotateY(-turnSpeed * (plane.position.y <= 2 ? 1 : controlPower)); 

            // Forward movement
            plane.translateZ(-speed);

            // --- UPDATE TRAFFIC ---
            cars.forEach(car => {
                car.position.z += car.userData.speed * car.userData.dir;
                if(car.position.z > 2000 || car.position.z < -2000) car.userData.dir *= -1; // Turn around
            });

            // --- COLLISIONS ---
            planeBox.setFromObject(plane);
            for (let b of buildings) {
                buildingBox.setFromObject(b);
                if (planeBox.intersectsBox(buildingBox)) resetFlight();
            }

            // --- CAMERA & HUD ---
            const camOffset = new THREE.Vector3(0, 10, 30).applyMatrix4(plane.matrixWorld);
            camera.position.lerp(camOffset, 0.1);
            camera.lookAt(new THREE.Vector3(0, 0, -50).applyMatrix4(plane.matrixWorld));

            document.getElementById('speedometer').innerText = `Speed: ${Math.floor(speed * 60)} kts`;
            document.getElementById('altimeter').innerText = `Alt: ${Math.floor((plane.position.y - 2) * 10)} ft`;

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
